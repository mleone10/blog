<!doctype html><html><head><link rel=stylesheet href=/css/ditalini.css><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><link rel=preconnect href=https://fonts.googleapis.com><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link rel=stylesheet href="https://fonts.googleapis.com/css2?family=Open+Sans&display=swap"><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css><title>Mario Leone | How I Structure Go CLI Projects</title></head><body><nav class="mainNav fullWidth"><h1><a href=https://mleone.dev>Mario Leone</a></h1><ul><li><a href=/about/>About Me</a></li><li><a href=https://mleone.dev/tags/>Tags</a></li></ul></nav><main><article class="single h-entry"><header><h2><a class="p-name u-url" href=https://mleone.dev/posts/structuring-go-clis/>How I Structure Go CLI Projects</a></h2><span class=byline><a class="p-author h-card" href=https://mleone.dev>Mario Leone</a>
&#183;&nbsp;<time class=dt-published datetime=2020-09-20T14:54:19-0400>
September 20, 2020</time>
&#183;
<a class=p-category href=https://mleone.dev/tags/tech/>Tech</a>, <a class=p-category href=https://mleone.dev/tags/go/>Go</a></span></header><div class=e-content><p><strong>At work, I have a bit of a reputation as &ldquo;the Go guy&rdquo;.</strong> Nevermind that I&rsquo;ve never technically run an enterprise-grade production service written in Go, but I&rsquo;ve apparently been vocal enough in my advocacy for the language that it stuck. I have, however, written a few different command line tools that I&rsquo;m fairly proud of, and have established some patterns that make development much easier.</p><h2 id=repository-structure>Repository Structure</h2><p>Whenever I start a new Go project, I usually use the same high-level repository structure:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>.
├── cmd
│   └── examplecmd
│       └── main.go
├── go.mod
├── internal
│   └── library.go
├── Makefile
└── README.md
</code></pre></div><p>First, always start by initializing a git repository with <code>git init</code>. It&rsquo;s quick, it&rsquo;s nearly universal, and it&rsquo;ll no doubt end up saving you a massive headache down the road. Additionally, initialize a Go module:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>$ go mod init github.com/mleone10/go-cli-example
</code></pre></div><p>I use GitHub, so my module&rsquo;s path reflects the remote repository to which I&rsquo;ll be pushing my code.</p><p>Next, create an empty Makefile and README with <code>touch Makefile README.md</code>. We&rsquo;ll discuss the Makefile later. A README is another good practice for every repository. It doesn&rsquo;t have to contain much for now - you can add documentation as your project evolves. For fantastic advice about the contents of a README, see Danny Guo&rsquo;s <a href=https://www.makeareadme.com/>Make a README</a>.</p><p>The last thing we&rsquo;ll do is set up our source directories. In Go, it&rsquo;s common to isolate executables in their own <code>cmd</code> directory, within which there are subdirectories for each individual executable. Those subdirectories are required due to the way Go&rsquo;s build tooling groups code. All of the <code>*.go</code> files within a single directory constitute a package. Additionally, Go handles the <code>internal</code> directory in a special way. Any packages located within a module&rsquo;s <code>internal</code> directory can only be used by that module. This way, you can separate application-specific code from code others can import into their own projects.</p><h2 id=executable-vs-library-code>Executable vs Library Code</h2><p>In this directory structure, the <code>main.go</code> executable code should be kept as small as possible. In the cases I&rsquo;ve encountered, this means parsing flags and calling out to <code>internal</code> library methods. Our example <code>main.go</code> contains the following:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#f92672>package</span> <span style=color:#a6e22e>main</span>

<span style=color:#f92672>import</span> (
	<span style=color:#e6db74>&#34;github.com/mleone10/go-cli-example/internal&#34;</span>
)

<span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {
	<span style=color:#a6e22e>internal</span>.<span style=color:#a6e22e>Hello</span>()
}
</code></pre></div><p>All I&rsquo;m doing is calling out to my <code>internal</code> package, which consists of a single <code>library.go</code> file:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#f92672>package</span> <span style=color:#a6e22e>internal</span>

<span style=color:#f92672>import</span> <span style=color:#e6db74>&#34;fmt&#34;</span>

<span style=color:#66d9ef>func</span> <span style=color:#a6e22e>Hello</span>() {
	<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#e6db74>&#34;Hello there!&#34;</span>)
}
</code></pre></div><p>It&rsquo;s easy to imagine extending this as your use case demands. Perhaps you need to call out to an API using code located within <code>internal/apiclient</code>. Or maybe you need to query a database with a client in <code>internal/db</code>. The pattern is the same in either case. The key takeaway, though, is to keep anything <em>not</em> strictly related to the command line-based interface out of the executable code.</p><h2 id=input-output-and-logs>Input, Output, and Logs</h2><p>I tend to be a <a href=https://en.wikipedia.org/wiki/Unix_philosophy>Unix Philosophy</a> fanboy in many ways. Specifically, I always start designing software by thinking about the interfaces: databases, APIs, queues, files. And when it comes to small CLI tools, those interfaces tend to be STDIN, STDOUT, and STDERR.</p><p>The <a href=https://en.wikipedia.org/wiki/Standard_streams>standard streams</a> are a key aspect of terminal-based programs, and Go supports interactions with them perfectly.</p><p>Whenever I need to read in data, I build my executable to read from STDIN. Let <code>cat</code> read from files, build your program to accept STDIN:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#75715e>// Source: https://stackoverflow.com/a/28311177
</span><span style=color:#75715e></span><span style=color:#a6e22e>scanner</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>bufio</span>.<span style=color:#a6e22e>NewScanner</span>(<span style=color:#a6e22e>os</span>.<span style=color:#a6e22e>Stdin</span>)
<span style=color:#66d9ef>for</span> <span style=color:#a6e22e>scanner</span>.<span style=color:#a6e22e>Scan</span>() {
    <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#a6e22e>scanner</span>.<span style=color:#a6e22e>Text</span>())
}
</code></pre></div><p>Standard out (STDOUT) is designed to be consumed by another program. So you should assume that some other program is reading whatever you send to STDOUT and structure it accordingly. CSVs, JSON, and other line-delimited data formats are perfect for this. As for writing to STDOUT, fear not - the standard library&rsquo;s <code>fmt.Print*</code> methods already do that for you:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#e6db74>&#34;&#34;</span>)
<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Printf</span>(<span style=color:#e6db74>&#34;%s&#34;</span>, <span style=color:#e6db74>&#34;&#34;</span>)
<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Print</span>(<span style=color:#e6db74>&#34;&#34;</span>)
</code></pre></div><p>Finally, standard error might be more appropriately named &ldquo;standard diagnostic&rdquo;. I like using STDERR for human readable logs and errors - various ways I can keep track of a program&rsquo;s execution without muddying the output. Once again, the standard library comes to the rescue. By default, the <code>log</code> package writes to STDERR:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#a6e22e>log</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#e6db74>&#34;&#34;</span>)
</code></pre></div><p>In practice, programs that use all three standard streams are executed using <a href=https://www.digitalocean.com/community/tutorials/an-introduction-to-linux-i-o-redirection>I/O redirection</a>. The following will read the contents from <code>input.txt</code> and send it into <code>examplecmd</code>. Output data will go to <code>output.txt</code>, while logs (STDERR) will stay on the terminal:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>$ cat input.txt | examplecmd &gt; output.txt
</code></pre></div><h2 id=build-scripts>Build Scripts</h2><p>Building executables in this structure is a bit tricky due to the nested nature of the <code>cmd</code> directory. First, the solution I&rsquo;ve arrived at. Although it&rsquo;s a definitely a bastardization of <code>make</code>'s original purpose, I really do like using <code>Makefile</code>s for common scripting tasks. The tool is nearly universal, and removes the need to document small commands in a README or elsewhere.</p><p>In a <code>Makefile</code>, I put the following:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-makefile data-lang=makefile><span style=color:#a6e22e>clean</span><span style=color:#f92672>:</span>
        rm -rf ./bin

<span style=color:#a6e22e>build</span><span style=color:#f92672>:</span> clean
        <span style=color:#66d9ef>for</span> CMD in <span style=color:#e6db74>`</span>ls cmd<span style=color:#e6db74>`</span>; <span style=color:#66d9ef>do</span> <span style=color:#ae81ff>\
</span><span style=color:#ae81ff></span>                env GOOS<span style=color:#f92672>=</span>linux go build -ldflags<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;-s -w&#34;</span> -o bin/$$CMD ./cmd/$$CMD/...; <span style=color:#ae81ff>\
</span><span style=color:#ae81ff></span>        <span style=color:#66d9ef>done</span>
</code></pre></div><p>And now, the explanation. Go&rsquo;s <code>build</code> and <code>install</code> subcommands are used to compile code into executables, but they work slightly differently when the active directory is not on the GOPATH. The above <code>Makefile</code> script is the best way I&rsquo;ve found to overcome those challenges and enable compilation of multiple executables in one project.</p><p>When you run <code>make build</code>, the script first wipes away any already-built binaries in <code>./bin</code>. It then lists all subdirectories of <code>./cmd</code>. For each (which conceivably represent a single binary to be built), it executes <code>go build</code>. The invocation specifies that built binaries should be placed in <code>./bin</code>.</p><p>Your project&rsquo;s <code>Makefile</code> can be further extended to support other scripts for running, testing, or deploying. For example, you might script a local run of an executable by prefacing it with necessary environment variables:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Makefile data-lang=Makefile><span style=color:#a6e22e>run</span><span style=color:#f92672>:</span> clean build
        PROPS_FILE<span style=color:#f92672>=</span>./localProps.json PORT<span style=color:#f92672>=</span><span style=color:#ae81ff>8080</span> ./bin/examplecmd
</code></pre></div><p>This has the added benefit of linking your <code>run</code> script with your <code>clean</code> and <code>build</code> scripts. <code>Make</code> will run the dependent stages in the order they appear before running the target stage. So <code>make run</code> will remove old binaries, rebuild them, and run the resultant executable.</p><h2 id=conclusion>Conclusion</h2><p>In this post, we examined one minimalist approach to structuring small Go projects. We established a basic repository structure, separated code into executable and library components, discussed I/O, and created a simple way to build the project&rsquo;s executables.</p><p>I&rsquo;ve pushed the aggregate examples from this post to a <a href=https://github.com/mleone10/go-cli-example>GitHub template repository</a>. Feel free to take a closer look at it and apply it to future projects of your own.</p><p>Until next time,<br>- Mario</p></div></article></main><footer class="fullWidth h-card"><img class=u-photo src=/profilePic.jpeg>
<span><p class=p-note>Hi, I'm Mario! Software engineering manager, actor, DIY-enthusiast. Trying new things every day and living life to the fullest!</p><p>&copy;
2023
<a class="p-name u-url u-uid" href=https://mleone.dev>Mario Leone</a>
<a class=u-url rel=me href=https://github.com/mleone10><i class="fa-brands fa-github"></i></a><a class=u-url rel=me href=https://linkedin.com/in/mleone5244><i class="fa-brands fa-linkedin"></i></a><a class=u-url rel=me href=https://hachyderm.io/@mleone><i class="fa-brands fa-mastodon"></i></a></p></span></footer></body></html>